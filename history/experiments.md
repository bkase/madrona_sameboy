# Experiments

- 2026-01-20: CPU benchmark (headless --benchmark, 120 frames). 64 worlds: 7680 frames in 0.256s = 29,993 fps total; 256 worlds: 30,720 frames in 0.819s = 37,530 fps total.
- 2026-01-20: GPU benchmark (headless_gpu --benchmark, 120 frames). 64 worlds: 7680 frames in 18.055s = 425 fps total (6.65 per-world); 256 worlds: 30,720 frames in 39.25s = 783 fps total (3.06 per-world).
- 2026-01-20: CPU benchmark sweep (headless --benchmark, 120 frames). Worlds=1: 2,878 fps total; 8: 10,407; 32: 28,710; 64: 30,946; 128: 36,885; 256: 39,095; 512: 39,584; 1024: 39,827.
- 2026-01-20: GPU benchmark sweep (headless_gpu --benchmark, 120 frames). Worlds=1: 17.56 fps total; 8: 120.22; 32: 314.56; 64: 426.99; 128: 587.32; 256: 778.99; 512: 1332.88; 1024: 1965.51. (Per-world FPS declines with scale.)
- 2026-01-20: Nsight Systems (nsys profile, 512 worlds, 10 frames, --cuda-graph-trace=node). GPU kernel summary shows madronaMWGPUMegakernel_256_1_48 dominating: 10 instances, ~390 ms avg per frame (total 3.90s). CPU-side cudaStreamSynchronize accounts for ~93% of runtime, consistent with long GPU kernel time.
- 2026-01-20: Nsight Compute (ncu) attempt on madronaMWGPUMegakernel_256_1_48 failed due to ERR_NVGPUCTRPERM (no permission to access GPU performance counters). Collected no metrics.
- 2026-01-20: GPU benchmark with batched frames (headless_gpu --benchmark cpu_instrs.gb 120 512 0 4). Frames per world=480; total throughput 1297.16 fps (2.53 FPS/world), slightly worse than framesPerStep=1 baseline (~1332 fps), suggesting launch overhead is not the primary bottleneck.
- 2026-01-20: Attempted occupancy tuning via MADRONA_MWGPU_ENABLE_PGO=1 (to allow >1 blocks/SM) failed at NVJitLink with max-regcount mismatch errors for megakernel variants (e.g., madronaMWGPUMegakernel_256_{2..6}_48), so multi-block configs are currently unbuildable in this setup.
- 2026-01-20: Null-step baseline (no GB_run_frame, minimal component touches). CPU headless --benchmark --null-step cpu_instrs.gb 120 512: 143,306 fps total (~279.9 FPS/world). GPU headless_gpu --benchmark --null-step cpu_instrs.gb 120 512: 27,700,631 fps total (~54,102.8 FPS/world). ECS overhead is negligible relative to emulator cost.
- 2026-01-20: GPU fast_ppu attempt (headless_gpu --benchmark --fast-ppu cpu_instrs.gb 120/10 512) hits CUDA_ERROR_ILLEGAL_ADDRESS on teardown, so fast_ppu path is unsafe on GPU and blocks testing PPU cost.
- 2026-01-20: compute-sanitizer memcheck (headless_gpu --benchmark --fast-ppu cpu_instrs.gb 1 1) reports invalid global write in StateManager::makeEntityNow (state.cpp:523) during initWorlds, followed by unspecified launch failure; likely same init bug seen previously.
- 2026-01-20: compute-sanitizer memcheck (headless_gpu --benchmark --null-step cpu_instrs.gb 1 1) reproduces the same invalid global write in StateManager::makeEntityNow during initWorlds, confirming it is independent of emulation work.
- 2026-01-20: fast_ppu GPU run with 1 world (headless_gpu --benchmark --fast-ppu cpu_instrs.gb 1 1) succeeds (~0.41 fps), while 512-world fast_ppu runs crash, suggesting the illegal access is scale-dependent.
- 2026-01-20: Set GBMachine max entities per world to 1 (registry.registerArchetype with max=1). compute-sanitizer memcheck on --null-step still reports invalid write in StateManager::makeEntityNow (state.cpp:523), so limiting max entities does not resolve the initWorlds error.
- 2026-01-20: compute-sanitizer memcheck (headless_gpu --benchmark --null-step cpu_instrs.gb 1 1) still reports invalid global write in StateManager::makeEntityNow after reverting GBMachine max entities per world to default (0). Nearest allocation reported as 2,097,152 bytes; access at +0x4 flagged out-of-bounds, so issue is not caused by max-entities-per-world override.
- 2026-01-20: MADRONA_MWGPU_VERBOSE_HOSTALLOC=1 (headless_gpu --benchmark --null-step cpu_instrs.gb 1 1) shows entity/world column allocations of 8 and 4 bytes, plus larger component buffers; run completes at ~3984 fps without crash, suggesting compute-sanitizer error may be tied to memory API tracking or a subtle init write bug.
- 2026-01-20: GPU build experiment: removed camera/printer/rumble/sgb/workboy from sameboy_core_gpu.cpp and added stub implementations in src/sameboy_gpu_stubs.c. Initial stub version including gb.h caused NVRTC extern "C" template errors; switching to forward-declare GB_gameboy_t + local GB_ENUM resolved compile. headless_gpu --benchmark --null-step cpu_instrs.gb 1 1 runs successfully (~2227 fps total).
- 2026-01-20: GPU float-avoidance: added GB_GPU_MODE fast paths in display.c (skip gamma/temperature float math, linear scale only) and joypad.c (faux analog inputs no-op). headless_gpu --benchmark --null-step cpu_instrs.gb 1 1 runs successfully (~3649.64 fps total).
- 2026-01-20: Validated headless_gpu does not copy obs/input each frame (only initial input upload + optional end obs readback). Ran build/headless_gpu cpu_instrs.gb 120 1 0: 120 frames in 6.785s (~17.69 FPS), observation range [0,0] with rendering disabled.
- 2026-01-20: MADRONA_MWGPU_ENABLE_PGO compile now succeeds after removing launch-bounds min-blocks and maxrregcount for multi-configs; baseline PGO run (headless_gpu --benchmark cpu_instrs.gb 20 512 0) hit 10,240 frames in 8.189s = 1250.43 fps total (2.44 FPS/world).
- 2026-01-20: PGO baseline at higher frame count (headless_gpu --benchmark cpu_instrs.gb 60 512 0) completed in 23.579s = 1302.86 fps total (2.54 FPS/world).
- 2026-01-20: MADRONA_MWGPU_EXEC_CONFIG_OVERRIDE=256,2,48 with PGO hung/timed out (>120s) for 20 frames at 512 worlds and again at 32 worlds, suggesting multi-block megakernel configs deadlock or stall without guaranteed occupancy.
- 2026-01-20: Added GPU-only --skip-ppu option (approximate CPU-only cost by faking vblank every LCDC_PERIOD). Baseline headless_gpu --benchmark cpu_instrs.gb 20 512: 1278.80 fps total (2.50 FPS/world). With --skip-ppu: 4018.25 fps total (7.85 FPS/world), ~3.1x faster, suggesting PPU work is a major but not sole bottleneck.
- 2026-01-20: Added --render-every N (skip PPU on N-1 frames). headless_gpu --benchmark cpu_instrs.gb 20 512: 1386.82 fps total (2.71 FPS/world). With --render-every 4: 3096.64 fps total (6.05 FPS/world), ~2.2x faster, indicating render decimation helps but still far below CPU throughput.
